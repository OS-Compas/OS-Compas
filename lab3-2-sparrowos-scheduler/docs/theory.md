```markdown
# 进程调度器理论基础

## 1. 进程调度概述

### 1.1 什么是进程调度？
进程调度是操作系统的核心功能之一，负责决定哪个进程在何时使用CPU资源。调度的目标是：
- **公平性**: 所有进程都能获得合理的CPU时间
- **效率**: 最大化CPU利用率
- **响应时间**: 对交互式进程快速响应
- **吞吐量**: 单位时间内完成的工作量

### 1.2 调度时机
调度发生在以下情况：
1. 进程创建或终止
2. 进程阻塞（如等待I/O）
3. 中断发生
4. 时间片用完
5. 进程主动让出CPU

### 1.3 调度队列
- **就绪队列**: 等待CPU的进程
- **阻塞队列**: 等待I/O或其他事件的进程
- **运行状态**: 当前正在使用CPU的进程

## 2. 进程控制块 (PCB)

### 2.1 PCB的作用
PCB是操作系统管理进程的核心数据结构，包含：
- **进程标识信息**: PID、父进程PID
- **进程状态信息**: 状态、优先级、调度信息
- **CPU状态信息**: 寄存器值、程序计数器、栈指针
- **资源信息**: 打开的文件、内存分配、I/O设备

### 2.2 PCB的生命周期
1. **创建**: 进程创建时分配PCB
2. **更新**: 进程运行期间更新状态
3. **保存/恢复**: 上下文切换时保存和恢复
4. **释放**: 进程终止时回收PCB

### 2.3 PCB数据结构示例
```c
typedef struct process_control_block {
    uint32_t pid;           // 进程ID
    process_state_t state;  // 进程状态
    uint8_t priority;       // 优先级
    uint32_t time_used;     // 已使用CPU时间
    uint32_t reg_esp;       // 栈指针
    uint32_t reg_eip;       // 指令指针
    // ... 其他字段
} pcb_t;
3. 上下文切换
3.1 什么是上下文切换？
上下文切换是指保存当前进程的CPU状态，并恢复下一个进程的CPU状态的过程。这是多任务操作系统的核心机制。

3.2 上下文切换的步骤
保存当前上下文: 将CPU寄存器保存到当前进程的PCB中

更新进程状态: 将当前进程状态改为就绪

选择下一个进程: 调度算法选择要运行的进程

恢复新上下文: 从新进程的PCB恢复CPU寄存器

更新状态: 将新进程状态改为运行

3.3 上下文切换的开销
直接开销: 保存/恢复寄存器的时间

间接开销: 缓存失效、TLB刷新等

优化策略: 减少切换频率、优化保存/恢复代码

4. 中断与定时器
4.1 中断的作用
中断是硬件或软件发出的信号，用于通知CPU有重要事件需要处理。在调度器中，定时器中断用于：

实现时间片轮转

收集运行时间统计

触发定期调度决策

4.2 定时器中断处理流程
中断发生: 定时器硬件产生中断信号

保存现场: 自动保存部分寄存器

中断服务例程 (ISR): 执行中断处理代码

调度决策: 检查是否需要重新调度

恢复现场: 恢复寄存器，返回被中断的代码

4.3 定时器编程
c
// 设置定时器频率
void timer_init(uint32_t frequency) {
    uint32_t divisor = 1193180 / frequency;
    outb(0x36, 0x43);  // 命令端口
    outb(divisor & 0xFF, 0x40);  // 数据端口低字节
    outb((divisor >> 8) & 0xFF, 0x40);  // 数据端口高字节
}
5. 调度算法
5.1 先来先服务 (FIFO/FCFS)
原理: 按进程到达顺序调度

优点: 实现简单、无饥饿

缺点: 平均等待时间长、对短进程不友好

适用场景: 批处理系统

5.2 最短作业优先 (SJF)
原理: 选择估计运行时间最短的进程

优点: 最小化平均等待时间

缺点: 需要预知运行时间、可能导致饥饿

变体: 最短剩余时间优先 (SRTF)

5.3 优先级调度
原理: 为每个进程分配优先级，选择优先级最高的

优先级类型:

静态优先级: 创建时确定，不变

动态优先级: 运行时根据行为调整

问题: 低优先级进程可能饥饿

解决方案: 优先级老化 (aging)

5.4 时间片轮转 (Round-Robin)
原理: 每个进程获得固定的时间片，时间片用完则重新调度

时间片大小的影响:

太小: 上下文切换开销大

太大: 响应时间变差

优点: 公平、响应时间可预测

缺点: 对I/O密集型进程不友好

5.5 多级反馈队列 (MLFQ)
原理: 多个优先级队列，进程可在队列间移动

关键规则:

如果A的优先级 > B的优先级，运行A

如果A的优先级 = B的优先级，轮转运行A和B

新进程进入最高优先级队列

进程用完时间片后降级

进程主动让出CPU时保持优先级

定期提升所有进程的优先级（防止饥饿）

优点: 结合了响应时间和吞吐量的优点

缺点: 实现复杂、需要调优参数

5.6 完全公平调度器 (CFS)
原理: 跟踪每个进程的虚拟运行时间，选择运行时间最少的进程

核心概念:

虚拟运行时间 (vruntime)

红黑树用于快速查找最小vruntime进程

调度粒度控制

优点: 高度公平、良好的交互性能

缺点: 实现复杂、需要维护平衡树

6. 调度性能指标
6.1 主要指标
CPU利用率: CPU忙碌时间的百分比

吞吐量: 单位时间内完成的进程数

周转时间: 从提交到完成的时间

包括等待时间和执行时间

等待时间: 进程在就绪队列中等待的总时间

响应时间: 从提交请求到第一次响应的时间

6.2 评价标准
批处理系统: 最大化吞吐量，最小化周转时间

交互式系统: 最小化响应时间

实时系统: 满足截止时间要求

7. 多处理器调度
7.1 挑战
负载均衡: 均匀分配工作负载

缓存亲和性: 进程在同一个CPU上运行以减少缓存失效

同步开销: 多CPU间的通信和同步

7.2 调度策略
对称多处理 (SMP): 所有CPU平等

非对称多处理 (AMP): 一个主CPU负责调度

处理器亲和性: 将进程绑定到特定CPU

8. 实时调度
8.1 实时系统要求
可预测性: 最坏情况执行时间可预测

确定性: 在规定时间内完成任务

优先级继承: 防止优先级反转

8.2 实时调度算法
速率单调调度 (RMS): 周期越短，优先级越高

最早截止时间优先 (EDF): 选择截止时间最早的进程

最小松弛度优先 (LLF): 选择松弛度最小的进程

9. 现代调度器趋势
9.1 能耗感知调度
考虑CPU功耗特性

动态电压频率调整 (DVFS)

核心关闭和休眠

9.2 容器和虚拟化调度
容器级别的资源隔离

虚拟机调度

云计算环境中的调度

9.3 机器学习在调度中的应用
使用历史数据预测进程行为

自适应调度参数调整

智能负载均衡

10. 实验相关理论
10.1 实验设计要点
模块化设计: 调度算法可插拔

可测试性: 提供丰富的测试用例

可扩展性: 易于添加新调度算法

可观测性: 提供详细的统计信息

10.2 调试技巧
日志输出: 关键操作的详细日志

断言检查: 重要不变量检查

可视化工具: 调度过程可视化

性能分析: 识别性能瓶颈

10.3 学习建议
从简单开始: 先实现FIFO，逐步增加复杂度

理解原理: 不只是写代码，要理解算法原理

对比分析: 比较不同算法的性能

实际应用: 思考算法在实际系统中的应用

参考资料
经典论文
"A Scheduler for Multiprogramming in a Hard-Real-Time Environment" (1973)

"The Multics Virtual Memory" (1972)

"Linux Scheduler Evolution" (2003)

在线课程
MIT 6.828: Operating System Engineering

Stanford CS140: Operating Systems

CMU 15-410: Operating System Design and Implementation

实用工具
GDB: 调试器

Valgrind: 内存调试工具

Perf: Linux性能分析工具

SystemTap: 动态跟踪工具